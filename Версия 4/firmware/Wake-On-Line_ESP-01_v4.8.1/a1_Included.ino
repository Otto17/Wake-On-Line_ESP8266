//********** ПОДКЛЮЧЕНИЕ БИБЛИОТЕК, ОБЪЕКТОВ, КОНСТАНТ И ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ**********//


#include <LittleFS.h>          // Библиотека для работы с файловой системой ESP (подключать ДО библиотеки #include GyverPortal.h) [в ядре ESP8266]
#include <EEPROM.h>            // Библиотека для работы с энергонезависимой памятью EEPROM [в ядре ESP8266]
#include <MOD_SimplePortal.h>  // ФОРК библиотеки "SimplePortal". Простой WiFi менеджер с возможностью задания Логина/Пароля для WEB интерфейса [используется ver. 0.1]
#include <GyverPortal.h>       // Простой конструктор веб интерфейсов для ESP8266 и ESP32 "https://github.com/GyverLibs/GyverPortal" [используется ver. v3.6.6]
#include <microDS18B20.h>      // Лёгкая библиотека для работы сдатчиком температуры DS18B20 "https://github.com/GyverLibs/microDS18B20" [используется ver. 3.10]
#include "EncButton.h"         // Библиотека для работы с кнопками "https://github.com/GyverLibs/EncButton" [используется ver. 2.0]
#include <TimerMs.h>           // Многофункциональный программный таймер на системном таймере millis() "https://github.com/GyverLibs/TimerMs" [используется ver. 1.2]

#if (ENABLE_REMOTEXY == 1)  // Выполняется, если включено управление через RemoteXY

#define REMOTEXY_MODE__ESP8266WIFI_LIB_CLOUD  // Определение режима соединения и подключение библиотеки RemoteXY (подключать ДО библиотеки #include RemoteXY.h и после всех других библиотек, иначе будет ошибка)
#include <RemoteXY.h>                         // Библиотека для управления ESP8266/32 через приложение на смартфоне "https://github.com/RemoteXY/RemoteXY-Arduino-library" [используется ver. 3.1.10]

#endif


/* ГЛОБАЛЬНАЯ ИНИЦИАЛИЗАЦИЯ ОБЪЕКТОВ */

//WEB Конструктор
GyverPortal ui(&LittleFS);  // Создаём объект "ui" с подключенной файловой системой "LittleFS"

//Датчик температуры
MicroDS18B20<PIN_TEMP> sensor;  // Указываем пин в "<BUS_SENSOR>" (один датчик лучше читать без адресации, это экономит память)

//Кнопка на ESP
EncButton<EB_TICK, PIN_BUT > ButtSwRes;  // Создаём объект "ButtSwRes" класса "EncButton", "PIN_BUT" - это имя дерективы кнопки

//Таймеры на millis. (период, мс), (0 не запущен / 1 запущен), (режим: 0 период / 1 таймер)
TimerMs tmr_OnOff(OPTO_POWER, 0, 1);  // Создаём объект "tmr_OnOff" класса TimerMs для таймера Вкл./Выкл. ПК
TimerMs tmr_Reset(OPTO_RESET, 0, 1);  // Создаём объект "tmr_Reset" класса TimerMs для таймера Reset(Off) ПК




/* ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ */

//RemoteXY
#if (ENABLE_REMOTEXY == 1)  // Выполняется, если включено управление через RemoteXY

//Конфигурация интерфейса RemoteXY
//При изменении расположения элементов интерфейса или их изменении в онлайн редакторе, обязательно заменить массив и переменные в структуре (если это требуется)
#pragma pack(push, 1)
uint8_t RemoteXY_CONF[] =  // 130 байт
  { 255, 2, 0, 9, 0, 123, 0, 16, 30, 1, 1, 1, 3, 29, 13, 13, 15, 16, 82, 101,
    115, 101, 116, 0, 1, 2, 45, 28, 15, 15, 14, 31, 79, 110, 45, 79, 102, 102, 0, 70,
    32, 22, 4, 18, 18, 27, 135, 37, 0, 71, 56, 17, 45, 28, 28, 3, 2, 218, 75, 0,
    0, 32, 65, 0, 0, 112, 66, 0, 0, 32, 65, 0, 0, 32, 65, 0, 0, 0, 64, 24,
    194, 176, 208, 161, 0, 178, 0, 0, 32, 65, 0, 0, 184, 65, 94, 0, 0, 184, 65, 0,
    0, 52, 66, 36, 0, 0, 52, 66, 0, 0, 112, 66, 68, 49, 0, 71, 63, 29, 8, 134,
    76, 101, 103, 101, 110, 100, 95, 88, 89, 0 };


//Структура RemoteXY
struct {  // Структура определяет все переменные и события интерфейса управления RemoteXY

  //Входные переменные
  uint8_t butRes_XY;    // =1 если кнопка нажата, иначе =0
  uint8_t butOnOff_XY;  // =1 если кнопка нажата, иначе =0

  //Выходные переменные
  uint8_t led_Power_XY;  // Состояние LED в приложении 0, 1 или 2 [0 - неничего (просто серый фон), 1 - ON, 2 - Off]
  float temp_XY;         // Отправлять значения oт 10 до 60 (потому, что такой диапазон задал в WEB редавторе)
  float Graph_XY;        // Просто отправляем float в данную переменную, график сам будет строиться

  //Прочие переменные
  uint8_t connect_flag;  // =1 если соединение есть, иначе =0

} RemoteXY;
#pragma pack(pop)

#endif


//Температура
float tempC = 0.0;      // Получаем сюда температуру с плавающей точкой в градусах Цельсия (к примеру: 21.3)
String str_tempC = "";  // Получаем сюда температуру строкой с символами "°C" (к примеру: 21.3°C)

//LED
bool led_State;        // Состояние LED индикатора (Power LED)
bool flagRes = false;  // Флаг для быстрого мигания LED индикатором на ESP перед отпусканием кнопки после долгого удержания и последующим сбросом настроек ESP

//Выход отпопары на управление ПК
byte StateOptron = 0;  // Состояние для оптопары (0 - off, 1 - On/Off, 2 - Reset)

//Надпись для кнопки (Вкл./Выкл.)
String ButState;              // Переменная для сохранения надписи на кнопке в зависимости от состояния LED
String ButOn = "Включить";    // Надпись для изменения на кнопке Вкл./Выкл.
String ButOff = "Выключить";  // Надпись для изменения на кнопке Вкл./Выкл.

//Надпись состояния на WEB кнопке (ON/OFF)
String PowerState;        // Переменные для сохранения надписи рядом с индикатором в зависимости от состояния LED
String StateOn = "ON ";   // Надпись ON (в конце невидимый символ, для визуальной эстетики на WEB морде)
String StateOff = "OFF";  // Надпись OFF

PGM_P ColorTitle = GP_WHITE;  // Цвет надписей ON/OFF (макрос "PGM_P" – строка в программной памяти), по умолчанию для инициализации при Вкл. ESP Белый цвет
